name: E2E Tests

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
  workflow_dispatch:

jobs:
  e2e-minikube:
    name: E2E Tests (Minikube)
    runs-on: ubuntu-latest
    timeout-minutes: 20
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Minikube
        uses: medyagh/setup-minikube@latest
        with:
          minikube-version: 'latest'
          driver: docker
          container-runtime: docker
          cpus: 2
          memory: 4096
          start-args: '--force'  # Required for running as root in CI containers

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Setup Timoni
        uses: stefanprodan/timoni/actions/setup@main
        with:
          version: latest

      - name: Start Mock Server
        run: |
          echo "Starting mock server..."
          bun run e2e/mock-server/index.ts &
          sleep 3

          echo "Verifying mock server..."
          curl -f http://localhost:8080/health || exit 1
          echo "✓ HTTP mock server started"

          # Verify gRPC server is listening
          nc -z localhost 50151 && echo "✓ gRPC mock server started on port 50151" || echo "✗ gRPC mock server not accessible"

      - name: Start Database Services
        run: |
          echo "Starting database services with Docker Compose..."
          docker compose -f docker-compose.e2e.yml up -d

          echo "Waiting for services to be healthy..."
          # Wait for MySQL (using docker exec to check inside container)
          echo "Waiting for MySQL..."
          timeout 60 bash -c 'until docker compose -f docker-compose.e2e.yml exec -T mysql mysqladmin ping -h localhost -u root -prootpass 2>/dev/null; do sleep 2; done'
          echo "✓ MySQL ready"

          # Wait for PostgreSQL (using docker exec to check inside container)
          echo "Waiting for PostgreSQL..."
          timeout 30 bash -c 'until docker compose -f docker-compose.e2e.yml exec -T postgresql pg_isready -U testuser -d testdb 2>/dev/null; do sleep 2; done'
          echo "✓ PostgreSQL ready"

          # Wait for Redis (no auth)
          echo "Waiting for Redis..."
          timeout 30 bash -c 'until docker compose -f docker-compose.e2e.yml exec -T redis redis-cli ping 2>/dev/null | grep -q PONG; do sleep 2; done'
          echo "✓ Redis ready"

          # Wait for Redis with auth
          echo "Waiting for Redis (with auth)..."
          timeout 30 bash -c 'until docker compose -f docker-compose.e2e.yml exec -T redis-auth redis-cli -a testpass ping 2>/dev/null | grep -q PONG; do sleep 2; done'
          echo "✓ Redis (with auth) ready"

          # Verify host port bindings
          echo "Verifying host ports..."
          nc -z localhost 13306 && echo "✓ MySQL port 13306 accessible" || echo "✗ MySQL port 13306 not accessible"
          nc -z localhost 15432 && echo "✓ PostgreSQL port 15432 accessible" || echo "✗ PostgreSQL port 15432 not accessible"
          nc -z localhost 16379 && echo "✓ Redis port 16379 accessible" || echo "✗ Redis port 16379 not accessible"
          nc -z localhost 16380 && echo "✓ Redis (auth) port 16380 accessible" || echo "✗ Redis (auth) port 16380 not accessible"

          echo "All database services started"
          docker compose -f docker-compose.e2e.yml ps

      - name: Get Host IP for Minikube
        id: hostip
        run: |
          # Get the host IP that Minikube can use to reach the mock server
          # For Docker driver, use host.minikube.internal or the docker bridge gateway
          MOCK_HOST=$(minikube ssh "cat /etc/hosts | grep host.minikube.internal | awk '{print \$1}'" | tr -d '\r')
          if [ -z "$MOCK_HOST" ]; then
            # Fallback: get docker bridge gateway
            MOCK_HOST=$(docker network inspect bridge --format '{{range .IPAM.Config}}{{.Gateway}}{{end}}')
          fi
          echo "mock_host=$MOCK_HOST" >> $GITHUB_OUTPUT
          echo "Mock server will be accessible at: $MOCK_HOST"

          # Verify connectivity from minikube to host
          echo "Testing connectivity..."
          minikube ssh "curl -sf http://${MOCK_HOST}:8080/health" || echo "Warning: Could not reach mock server from minikube"

      - name: Build Docker images
        run: |
          # Build images in minikube's docker
          eval $(minikube docker-env)

          echo "Building yuptime-api image..."
          docker build -t yuptime-api:latest -f Dockerfile .

          echo "Building yuptime-checker image..."
          docker build -t yuptime-checker:latest -f Dockerfile.checker .

          echo "Images built:"
          docker images | grep yuptime

      - name: Create values file for CI
        run: |
          cat > values-ci.cue << 'EOF'
          values: {
            image: {
              repository: "yuptime-api"
              tag:        "latest"
              digest:     ""
              pullPolicy: "Never"
            }

            checkerImage: {
              repository: "yuptime-checker"
              tag:        "latest"
              digest:     ""
              pullPolicy: "Never"
            }

            mode: "development"
            logging: level: "debug"

            probes: {
              liveness: {
                enabled: true
                initialDelaySeconds: 60
                periodSeconds: 30
                timeoutSeconds: 10
                failureThreshold: 5
              }
              readiness: {
                enabled: true
                initialDelaySeconds: 30
                periodSeconds: 10
                timeoutSeconds: 5
                failureThreshold: 5
              }
            }

            crds: install: true
            test: enabled: true
          }
          EOF

      - name: Deploy with Timoni
        run: |
          echo "Validating Timoni module..."
          timoni mod vet ./timoni/yuptime

          echo "Deploying Yuptime..."
          timoni apply yuptime ./timoni/yuptime -n yuptime -f values-ci.cue --timeout=5m

      - name: Apply Database Secrets
        run: |
          echo "Applying database secrets for E2E tests..."
          kubectl apply -f e2e/k8s/database-secrets.yaml
          echo "✓ Database secrets applied"
          kubectl get secrets -n yuptime

      - name: Wait for deployment
        timeout-minutes: 3
        run: |
          echo "Waiting for deployment to be ready..."
          kubectl rollout status deployment/yuptime-api -n yuptime --timeout=120s

          echo "Checking pod status..."
          kubectl get pods -n yuptime

      - name: Debug on failure
        if: failure()
        run: |
          echo "=== Pod Status ==="
          kubectl get pods -n yuptime -o wide
          echo ""
          echo "=== Pod Descriptions ==="
          kubectl describe pods -n yuptime
          echo ""
          echo "=== Pod Logs ==="
          kubectl logs -n yuptime -l app.kubernetes.io/name=yuptime --tail=100 || true
          echo ""
          echo "=== Events ==="
          kubectl get events -n yuptime --sort-by='.lastTimestamp'

      - name: Verify CRDs installed
        run: |
          echo "Checking CRDs..."
          kubectl get crds | grep yuptime

          expected_crds=(
            "monitors.monitoring.yuptime.io"
            "monitorsets.monitoring.yuptime.io"
            "maintenancewindows.monitoring.yuptime.io"
            "silences.monitoring.yuptime.io"
            "yuptimesettings.monitoring.yuptime.io"
          )

          for crd in "${expected_crds[@]}"; do
            if kubectl get crd "$crd" > /dev/null 2>&1; then
              echo "✓ CRD $crd exists"
            else
              echo "✗ CRD $crd not found"
              exit 1
            fi
          done

      - name: Health check
        timeout-minutes: 2
        run: |
          echo "Running health check..."
          kubectl port-forward svc/yuptime-api 3000:3000 -n yuptime &
          sleep 5

          max_retries=10
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            if curl -f http://localhost:3000/health; then
              echo ""
              echo "✓ Health check passed"
              break
            fi
            retry_count=$((retry_count + 1))
            echo "Retry $retry_count/$max_retries..."
            sleep 3
          done

          if [ $retry_count -eq $max_retries ]; then
            echo "✗ Health check failed after $max_retries retries"
            kubectl logs -n yuptime -l app.kubernetes.io/name=yuptime --tail=50
            exit 1
          fi

      - name: Create test monitor
        run: |
          cat > test-monitor.yaml << 'EOF'
          apiVersion: monitoring.yuptime.io/v1
          kind: Monitor
          metadata:
            name: httpbin-test
            namespace: yuptime
          spec:
            type: http
            schedule:
              intervalSeconds: 30
              timeoutSeconds: 10
            target:
              http:
                url: https://httpbin.org/get
                method: GET
            successCriteria:
              http:
                acceptedStatusCodes: [200]
          EOF

          kubectl apply -f test-monitor.yaml
          echo "✓ Test monitor created"

          # Wait for monitor to be processed
          sleep 10

          # Check monitor status
          echo "Monitor status:"
          kubectl get monitors -n yuptime -o wide

      - name: Wait for check job
        timeout-minutes: 3
        run: |
          echo "Waiting for check job to complete..."

          max_retries=20
          retry_count=0
          while [ $retry_count -lt $max_retries ]; do
            # Look for completed jobs
            completed=$(kubectl get jobs -n yuptime -l yuptime.io/monitor=httpbin-test --no-headers 2>/dev/null | grep -c "1/1" || echo "0")
            if [ "$completed" -gt 0 ]; then
              echo "✓ Check job completed"
              kubectl get jobs -n yuptime -l yuptime.io/monitor=httpbin-test
              break
            fi

            # Check for running jobs
            jobs=$(kubectl get jobs -n yuptime -l yuptime.io/monitor=httpbin-test --no-headers 2>/dev/null | wc -l)
            if [ "$jobs" -gt 0 ]; then
              echo "Jobs found: $jobs"
            fi

            retry_count=$((retry_count + 1))
            echo "Waiting... ($retry_count/$max_retries)"
            sleep 5
          done

          if [ $retry_count -eq $max_retries ]; then
            echo "Warning: No completed jobs found in time, checking status..."
            kubectl get jobs -n yuptime
            kubectl get pods -n yuptime
          fi

      - name: Verify API endpoints
        run: |
          echo "Testing API endpoints..."

          # Test monitors endpoint
          monitors=$(curl -s http://localhost:3000/api/monitors)
          echo "Monitors: $monitors"

          # Test status pages endpoint
          status=$(curl -s http://localhost:3000/api/status-pages)
          echo "Status pages: $status"

          echo "✓ API endpoints responding"

      - name: Run E2E Tests
        env:
          MOCK_SERVER_HOST: ${{ steps.hostip.outputs.mock_host }}
          E2E_NAMESPACE: yuptime
        run: |
          echo "Running E2E tests with mock server at $MOCK_SERVER_HOST..."
          bun test e2e/tests/ --timeout 120000

      - name: Cleanup
        if: always()
        run: |
          echo "Collecting logs..."
          kubectl logs -n yuptime -l app.kubernetes.io/name=yuptime --tail=100 || true

          echo "Cleaning up Kubernetes resources..."
          timoni delete yuptime -n yuptime || true
          kubectl delete namespace yuptime --ignore-not-found || true

          echo "Stopping database services..."
          docker compose -f docker-compose.e2e.yml down -v || true

      - name: Report results
        if: always()
        run: |
          echo "=========================================="
          echo "E2E Test Summary"
          echo "=========================================="
          echo "Minikube version: $(minikube version | head -1)"
          echo "Kubernetes version: $(kubectl version --short 2>/dev/null || kubectl version)"
          echo "Timoni version: $(timoni version)"
          echo "=========================================="
